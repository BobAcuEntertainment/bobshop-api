# BobShop API - Cursor Rules

## Project Overview
This is a cryptocurrency trading API built with Go that provides:
- Multi-exchange integration (Binance, Bitget, Bybit, CEX, Gate, MEXC, ProBit)
- Trading strategy management
- Order management and reporting
- Role-based access control
- WebSocket real-time updates
- File storage capabilities

## Code Style & Conventions

### Go Code Standards
- Use Go standard formatting with `gofmt`
- Follow Go naming conventions (PascalCase for exported, camelCase for unexported)
- Use descriptive variable and function names
- Add comments for all exported functions and types
- Use interfaces for better testability
- Handle errors explicitly, never ignore them

### API Design Patterns
- Follow RESTful principles
- Use consistent HTTP status codes (200, 400, 401, 403, 404, 409, 500)
- Group related endpoints by version and domain (/auth/v1, /cms/v1, /agent/v1)
- Use consistent response structures with proper error handling
- Implement proper authentication and authorization

### Database Patterns
- Use MongoDB ObjectId format for IDs (e.g., 671db9eca1f1b1bdbf3d4617)
- Include audit fields: updated_at, updated_by, created_at
- Use enum types for status fields (DataStatus, ServerStatus, etc.)
- Implement soft deletes with data_status field
- Use proper indexing for query performance

### Security Guidelines
- Always validate input data
- Use proper authentication (Bearer tokens, Basic auth)
- Implement permission-based access control
- Sanitize user inputs to prevent injection attacks
- Use secure password handling
- Implement rate limiting for public endpoints

## File Structure Patterns

### Data Transfer Objects (DTOs)
- Separate data models for different contexts (CmsData, CmsDto, BaseDto)
- Use validation tags for input validation
- Include proper JSON tags for API responses
- Separate creation/update data from response data

### Enums and Constants
- Define enums for status fields, permissions, exchanges
- Use descriptive enum values (enable/disable, create/update/delete)
- Group related constants together
- Use type-safe enum implementations

### Error Handling
- Use structured error responses with error and error_description
- Implement consistent error codes across endpoints
- Log errors with appropriate context
- Return user-friendly error messages

## Exchange Integration Patterns

### Supported Exchanges
- binance, bitget, bybit, cex, gate, mexc, probit
- Each exchange should have consistent interface implementation
- Support both sandbox and live trading modes
- Handle exchange-specific rate limits and requirements

### Trading Operations
- Implement order management (create, update, cancel, list)
- Support different order types and market operations
- Handle balance inquiries and position management
- Implement proper error handling for exchange failures

## API Endpoint Patterns

### Authentication Endpoints (/auth/v1)
- login, logout, refresh-token, change-password
- Implement proper session management
- Support cache flushing for security

### CMS Endpoints (/cms/v1)
- CRUD operations for all entities
- Consistent pagination (limit, page, sorts)
- Search functionality across entities
- Proper permission checks for each operation

### Agent Endpoints (/agent/v1)
- Server-to-server communication
- Order creation and status updates
- Config management for trading strategies

### Real-time Features
- WebSocket support for live updates
- Proper connection management
- Message broadcasting for order updates

## Development Guidelines

### Testing
- Write unit tests for all business logic
- Use table-driven tests for multiple scenarios
- Mock external dependencies (exchanges, databases)
- Test error conditions and edge cases
- Implement integration tests for API endpoints

### Documentation
- Keep Swagger documentation up to date
- Add examples for all request/response models
- Document error scenarios and status codes
- Include authentication requirements for each endpoint

### Performance
- Implement proper caching strategies
- Use connection pooling for database operations
- Optimize database queries with proper indexing
- Monitor API response times and implement timeouts

### Monitoring & Logging
- Log all significant operations with context
- Implement audit logging for sensitive operations
- Monitor exchange API calls and rate limits
- Track trading performance and system health

## Common Data Models

### Core Entities
- Users, Roles, Tenants (multi-tenancy support)
- Traders (exchange credentials)
- Strategies (trading algorithms)
- Configs (trading configurations)
- Orders (trade execution records)

### Financial Data
- Balances, Markets, Currencies, Networks
- OHLCV data, Tickers, OrderBooks, Trades
- Fees, Limits, Precision handling

### System Data
- Audit logs, Client credentials
- Server status, Configuration attributes
- File uploads (images, videos)

## Best Practices Specific to This Project

1. **Multi-Exchange Support**: Always design with multiple exchanges in mind
2. **Sandbox Mode**: Support both live and sandbox trading environments
3. **Audit Trail**: Log all significant operations for compliance
4. **Permission System**: Use granular permissions for different operations
5. **Real-time Updates**: Implement WebSocket for live trading data
6. **Error Recovery**: Handle exchange downtime and connectivity issues
7. **Data Validation**: Validate all trading parameters before execution
8. **Rate Limiting**: Respect exchange rate limits and implement backoff strategies 